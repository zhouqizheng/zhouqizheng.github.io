<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java 常见异常类型 | 一碗正气粥</title>

  
  <meta name="author" content="Qizheng.Zhou">
  

  
  <meta name="description" content="Java 常见异常类型
ArithmeticException 算数异常
IOException 输入输出异常
NoSuchMethodException 方法未找到
NumberFormatException
NullPointerException 空指针异常
ClassCastExceptio">
  

  
  
  <meta name="keywords" content="">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Java 常见异常类型"/>

  <meta property="og:site_name" content="一碗正气粥"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="一碗正气粥" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">一碗正气粥</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Java 常见异常类型</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2020/01/22/Java 常见异常类型/" rel="bookmark">
        <time class="entry-date published" datetime="2020-01-22T10:05:15.394Z">
          2020-01-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h4 id="Java-常见异常类型"><a href="#Java-常见异常类型" class="headerlink" title="Java 常见异常类型"></a>Java 常见异常类型</h4><ul>
<li>ArithmeticException 算数异常</li>
<li>IOException 输入输出异常</li>
<li>NoSuchMethodException 方法未找到</li>
<li>NumberFormatException</li>
<li>NullPointerException 空指针异常</li>
<li>ClassCastException 类型转换异常</li>
<li>ArrayIndexOutOfBoundsException 数组下标越界异常</li>
<li>EOFException 文件已结束异常</li>
</ul>
<h4 id="Kafka原理和容错"><a href="#Kafka原理和容错" class="headerlink" title="Kafka原理和容错"></a>Kafka原理和容错</h4><ol>
<li><p>kafka特性</p>
<ul>
<li><strong>高吞吐量、低延迟</strong>：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒</li>
<li><strong>可扩展性</strong>：kafka集群支持热扩展</li>
<li><strong>持久性、可靠性</strong>：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li>
<li><strong>容错性</strong>：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li>
<li><strong>高并发</strong>：支持数千个客户端同时读写</li>
</ul>
</li>
<li><p>重要思想</p>
<ul>
<li><strong>Consumer Group</strong>：各个consumer可以组成一个组，每个消息只能被组中的一个consumer消费，如果一个消息可以被多个consumer消费的话，那么这些consumer必须在不同的组。</li>
<li><strong>消息状态</strong>：在Kafka中，消息的状态被保存在consumer中，broker不会关心哪个消息被消费了被谁消费了，只记录一个offset值（指向partition中下一个要被消费的消息位置），这就意味着如果consumer处理不好的话，broker上的一个消息可能会被消费多次。</li>
<li><strong>消息持久化</strong>：Kafka中会把消息持久化到本地文件系统中，并且保持极高的效率。</li>
<li><strong>消息有效期</strong>：Kafka会长久保留其中的消息，以便consumer可以多次消费，当然其过期时间是可配置的。</li>
<li><strong>批量发送</strong>：Kafka支持以消息集合为单位进行批量发送，以提高push效率。</li>
<li><strong>push-and-pull</strong> : Kafka中的Producer和consumer采用的是push-and-pull模式，即Producer只管向broker push消息，consumer只管从broker pull消息，两者对消息的生产和消费是异步的。</li>
<li><strong>Kafka集群中broker之间的关系</strong>：不是主从关系，各个broker在集群中地位一样，我们可以随意的增加或删除任何一个broker节点。</li>
<li><strong>负载均衡方面</strong>： Kafka提供了一个 metadata API来管理broker之间的负载（对Kafka0.8.x而言，对于0.7.x主要靠zookeeper来实现负载均衡）。</li>
<li><strong>同步异步</strong>：Producer采用异步push方式，极大提高Kafka系统的吞吐率（可以通过参数控制是采用同步还是异步方式）。</li>
<li><strong>分区机制partition</strong>：Kafka的broker端支持消息分区，Producer可以决定把消息发到哪个分区，在一个分区中消息的顺序就是Producer发送消息的顺序，一个主题中可以有多个分区，具体分区的数量是可配置的。分区的意义很重大，后面的内容会逐渐体现。</li>
<li><strong>离线数据装载</strong>：Kafka由于对可拓展的数据持久化的支持，它也非常适合向Hadoop或者数据仓库中进行数据装载。</li>
<li><strong>插件支持</strong>：现在不少活跃的社区已经开发出不少插件来拓展Kafka的功能，如用来配合Storm、Hadoop、flume相关的插件。</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li><strong>日志收集</strong>：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</li>
<li><strong>消息系统</strong>：解耦和生产者和消费者、缓存消息等。<br>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</li>
<li><strong>运营指标</strong>：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li>
<li><strong>流式处理</strong>：比如spark streaming和storm</li>
<li><strong>事件源</strong></li>
</ul>
</li>
<li><p>容错（可用性）</p>
<p>在kafka中，正常情况下所有node处于<strong>同步中</strong>状态，当某个node处于<strong>非同步中</strong>状态，也就意味着整个系统出问题，需要做容错处理</p>
<p><strong>同步中</strong>代表了：</p>
<ul>
<li>该node与zookeeper能连通</li>
<li>该node如果是follower，那么consumer position与leader不能差距太大（差额可配置）</li>
</ul>
<p>某个分区内<strong>同步中</strong>的node组成一个集合，即该分区的ISR</p>
<p>kafka通过两个手段容错：</p>
<ul>
<li><p>数据备份：以partition为单位备份，副本数可设置。当副本数为N时，代表1个leader，N-1个followers，followers可以视为leader的consumer，拉取leader的消息，append到自己的系统中</p>
</li>
<li><p>failover：</p>
</li>
<li><ol>
<li>当leader处于<strong>非同步中</strong>时，系统从followers中选举新leader</li>
<li>当某个follower状态变为<strong>非同步中</strong>时，leader会将此follower剔除ISR，当此follower恢复并完成数据同步之后再次进入ISR</li>
</ol>
</li>
</ul>
<p>另外，kafka有个保障：当producer生产消息时，只有当消息被所有ISR确认时，才表示该消息提交成功。只有提交成功的消息，才能被consumer消费</p>
<p>综上所述：当有N个副本时，N个副本都在ISR中，N-1个副本都出现异常时，系统依然能提供服务</p>
<p>假设N副本全挂了，node恢复后会面临同步数据的过程，这期间ISR中没有node，会导致该分区服务不可用。kafka采用一种降级措施来处理：选举第一个恢复的node作为leader提供服务，以它的数据为基准，这个措施被称为<strong>脏leader选举</strong>。</p>
<p>由于leader是主要提供服务的，kafka broker将多个partition的leader均分在不同的server上以均摊风险</p>
<p>每个parition都有leader，如果在每个partition内运行选主进程，那么会导致产生非常多选主进程。kakfa采用一种轻量级的方式：从broker集群中选出一个作为controller，这个controller监控挂掉的broker，为上面的分区批量选主</p>
</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2020 Qizheng.Zhou
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>